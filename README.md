<h1>Кастомные аллокаторы</h1>
<hr>
<ul>
  <li>
    <h2>Линейный аллокатор</h2>
    Выделение памяти происходит за О(1), освобождение так же за О(1).
    Подобный эффект достигается откладыванием освобождения памяти до уничтожения аллокатора, т.е. выделенная этим аллокатором память освобождается только один раз - в деструкторе аллокатора. 
    Применяется в тех контейнерах, в которых заранее известно о малом числе хранимых в нем элементов.
  </li>
  <li>
    <h2>Стек-аллокатор</h2>
    Выделение памяти происходит за О(1), освобождение так же за О(1).
    Подобный эффект достигается за счет определенного порядка (LIFO) освобождение памяти. Применяется в тех контейнерах, в которых порядок освобождения памяти совпадает с порядком аллокатора.
  </li>
  <li>
    <h2>Pool-аллокатор</h2>
    Выделение памяти происходит за О(1), освобождение так же за О(1).
    Подобный эффект достигается за счет ограничения на выделяемый за раз память(все аллокации памяти заданного константного размера). Применяется в контейнерах, в которых размер выделяемой
    памяти не превышет заранее заданного порога.
  </li>
</ul>
<hr>
<h1>Результаты тестов:</h1>
<img src="result.png">
<p>Тесты, очевидно, вообще не объективны, т.к. замерялось реальное время исполнение кода, а оно разниться от случая к случаю и от железа к железу, но прирост производительности тем не менее очевиден.</p>
<p>Объявление аллокатора имеет следующий вид</p>

```cpp
template <typename Type>
class Allocator
// Type - тип аллоцируемого объекта
```

<p>Для указания размера памяти удобно использовать MemoryUnit</p>

```cpp
alloc::MemoryUnit<1, alloc::KiB>::byte(); // 1024
alloc::MemoryUnit<2, alloc::MB>::kilobyte(); // 1000
...
```

<p>Объявление конструкторов</p>

```cpp
// По умолчанию
Allocator()

// С пользовательским ресурсом памяти
Allocator(std::shared_ptr<alloc::MemoryResource> location)

// location - ресурс памяти, к которому будет обращаться аллокатор
// Если создать аллокатор с помощью конструктора по умолчанию, ресурсом
// памяти будет системная куча (т.е. это будет std::allocator)
```

<p>Создание ресурса памяти</p>

```cpp
// Конструктор
MemoryResource(manager_t mm_type = HEAP,
	size_t align = alignof(std::max_align_t), size_t t_size = sizeof(std::max_align_t),
	bool copy_assignment = false, size_t n = default_memory_size, size_t h = default_pool_h) noexcept

// mm_type         - тип управляющей структуры (HEAP, LINEAR, STACK или POOL)
// align           - выравнивание типа (предполагается что на ресурсе будут аллоцироваться одинаковые типы)
// t_size          - размер типа (служебная информация для аллокатора)
// copy_assignment - флаг, означающий возможность скопированного аллокатора использовать тот же ресурс
// n               - размер доступной ресурсу памяти
// h               - шаг (только для alloc::POOL)

// Создание
auto resource = alloc::make_resource(alloc::POOL, alignof(int), sizeof(int),
     false, alloc::default_memory_size, sizeof(int));
```



<p>Выделение памяти по умолчанию можно задать макросами (обязательно перед включением заголовка)</p>

```cpp
#define DEFAULT_MEMORY_SIZE 20, KiB // Общий размер памяти, предназначенной для аллоцирования объектов
#define META_MEMORY_SIZE 1, KiB // Размер памяти для хранения узлов управляющих структур
#include "alloc.hpp"
```

<p>Пример создания контейнера с линейным аллокатором</p>

```cpp
auto resource = alloc::make_resource(alloc::LINEAR);
alloc::Allocator<int> allocator(resource);
alloc::vector<int> example(allocator);
```
